#include "ndn-peer.hpp"
#include "ns3/random-variable-stream.h"
#include "ns3/ptr.h"
#include "ns3/log.h"
#include "ns3/simulator.h"
#include "ns3/packet.h"
#include "ns3/callback.h"
#include "ns3/string.h"
#include "ns3/boolean.h"
#include "ns3/uinteger.h"
#include "ns3/integer.h"
#include "ns3/double.h"

namespace ns3 {
namespace ndn {

// register NS-3 Type
TypeId
Peer::GetTypeId()
{
  static TypeId tid = TypeId("Peer")
    .SetParent<App>()
    .AddConstructor<Peer>()
    .AddAttribute("Frequency", "Frequency of record generation", StringValue("1"),
                  MakeIntegerAccessor(&Peer::m_frequency), MakeIntegerChecker<int32_t>())
    .AddAttribute("Randomize",
                  "Type of send time randomization: none (default), uniform, exponential",
                  StringValue("none"),
                  MakeStringAccessor(&Peer::SetRandomize, &Peer::GetRandomize),
                  MakeStringChecker());
  return tid;
}

Peer::Peer()
  : m_frequency(1.0)
  , m_firstTime(true)
  , m_weightThreshold(10)
  , m_entropyThreshold(10)
{
}

void
Peer::ScheduleNextGeneration()
{
  // double mean = 8.0 * m_payloadSize / m_desiredRate.GetBitRate ();
  // std::cout << "next: " << Simulator::Now().ToDouble(Time::S) + mean << "s\n";

  if (m_firstTime) {
    m_sendEvent = Simulator::Schedule(Seconds(0.0), &Peer::GenerateRecord, this);
    m_firstTime = false;
  }
  else if (!m_sendEvent.IsRunning()) {
    if (m_frequency == 0) {
      m_sendEvent = Simulator::Schedule((m_random == 0) ? Seconds(1.0 / 1)
                                        : Seconds(m_random->GetValue()),
                                        &Peer::GenerateRecord, this);
    }
    else {
      m_sendEvent = Simulator::Schedule((m_random == 0) ? Seconds(1.0 / m_frequency)
                                        : Seconds(m_random->GetValue()),
                                        &Peer::GenerateRecord, this);
    }
  }
}

void
Peer::ScheduleNextSync()
{
  //TODO
}

void
Peer::SetRandomize(const std::string& value)
{
  if (value == "uniform") {
    m_random = CreateObject<UniformRandomVariable>();
    m_random->SetAttribute("Min", DoubleValue(0.0));
    m_random->SetAttribute("Max", DoubleValue(2 * 1.0 / m_frequency));
  }
  else if (value == "exponential") {
    m_random = CreateObject<ExponentialRandomVariable>();
    m_random->SetAttribute("Mean", DoubleValue(1.0 / m_frequency));
    m_random->SetAttribute("Bound", DoubleValue(50 * 1.0 / m_frequency));
  }
  else
    m_random = 0;

  m_randomType = value;
}

std::string
Peer::GetRandomize() const
{
  return m_randomType;
}

// Processing upon start of the application
void
Peer::StartApplication()
{
   App::StartApplication();

   //TODO: Create hardcoded genesis records and add them to list of tips as current tips
   ScheduleNextGeneration();
}

// Processing when application is stopped
void
Peer::StopApplication()
{
  // cleanup App
  App::StopApplication();
}

// Generate a new record and send out notif and sync interest
void
Peer::GenerateRecord()
{

  //TODO:
    // generate random hash
    // create new data packet and set its name to prefix+hash
    // pick n records from tip list (if tip list size < n, repeat some)
    // set data contents to be reference1:referece2:...:referecen so that it is easy to parse
    // where reference1...n are names of tips
    // (note: we can keep record payload empty)
    // sign the data packet
    // attach it to local ledger i.e. add to map
    // increment weights of direct and indirect referred records
    // create and send out notif interest 
}


// Send out interest to fetch record
void
Peer::FetchRecord(std::string prefix)
{
  //TODO:
    // create and send interest with given prefix
}

// Callback that will be called when Data arrives
void
Peer::OnData(std::shared_ptr<const Data> data)
{
  //TODO:
    // ignore data if it is just reply to notif and sync interest
    // if data is a record:
      // Verification:
        // verify signature (PoA)
        // verify application level semantics (record is not already in ledger)
        // verify record does refer to records generated by same producer
        // ...
      // When verification passes, check if approved records are in local ledger
      // if not, retrieve them recursively and keep queuing
      // once all records are obtained, remove from queue and add to local ledger
      // (note if one of the records during sync fails to receive, discard entire queue)
      // increment weights of direct and indirect referred records
      // archive records that passes weight and entropy thresholds
}

// Callback that will be called when Interest arrives
void
Peer::OnInterest(std::shared_ptr<const Interest> interest)
{
  ///TODO:
    //  if interest is notif:
      // create and send interest to retrieve new record
    // if interest is sync:
      // compare tip list and figure out which tips are not present
      // send fetch record interest to retrieve those tips and missing records recursively
      // if there are some tips that are more recent in local ledger, broadcast sync interest
}

}
}
